---
title: ペンテストに備えるIoTデバイス開発環境の設計と実践的アプローチ
tags:
  - Security
  - devops
  - yocto
  - IoT
  - 組み込みLinux
private: true
updated_at: '2026-02-12T21:57:12+09:00'
id: 74dd58a0d9effc4e0d1a
organization_url_name: null
slide: false
ignorePublish: false
---
## はじめに

私たちShizen Connectは、「青い地球を未来へ繋ぐ」をミッションとして、再生可能エネルギーを効率良く生成・制御するために、クラウドからエッジまで全てのレイヤ技術を駆使して最先端のVPP技術を日々研究開発しています。

私はこの中で Shizen Box というエッジデバイスをメインに開発しています。Shizen Box は、エネルギーマネジメントシステムを支えるエッジ端末で、複数のプロトコル機器との接続・連系制御を可能とするデバイスです。

昨年、Shizen Boxは第三者ペネトレーションテスト（以下、ペンテスト）を実施しました。本記事では、私がペンテスト対応した実務経験をもとに、設計・実装・運用の観点で得られた知見を整理した連載を予定しています。

### 連載構成

- **第一回：開発・検証環境を整える**（本記事）
- 第二回：事前の守備固め（侵入対策・DOS対策など）
- 第三回：第三者ペネトレーションテストの実施内容
- 第四回：指摘された脆弱性
- 第五回：対策と運用改善

※ 各回は単体でも読めますが、時系列で読むと全体像が分かる構成としています。

### 第一回の内容

今回は、Shizen Box におけるフルスタック開発環境の設計と運用について説明します。

ペンテスト対応を見据えた開発環境の構築には、以下の要件がありました。

- 第三者ペネトレーションテストで指摘される可能性のある、全レイヤの脆弱性に対応できること
- キッティングから運用まで、一貫して自分たちで責任を持てる環境を構築すること
- 属人性を排除してチームレビュー可能な環境とすること

結果として、「理想的な構成」よりも実運用で最後まで自分たちが責任を持てる構成を優先しました。本記事では、その全体像と設計判断の背景、実装で直面した課題について紹介します。

## Shizen Boxの役割

Shizen Box は、エネルギーマネジメントシステムにおいて、太陽光発電や蓄電池などの複数のプロトコル機器との接続・連系制御を担うエッジ端末です。クラウドと現場機器の橋渡し役として、ECHONET LiteやModbusなどの多様なプロトコルを介した確実な機器制御と安全性の両立が求められます。

## Shizen Boxのアーキテクチャ

### 5つのレイヤ構成

Shizen Box は、典型的な IoT / エッジデバイスと同様に、複数レイヤで構成されています。

| レイヤ | 役割 | 管理の必要性 |
|--------|------|-------------|
| application | 機器制御、クラウド連携サービス | 機能追加・バグ修正の頻度が最も高い |
| rootfs | ユーザー空間の実行環境 | パッケージ脆弱性対応、設定変更 |
| Linux kernel | ハードウェア制御、デバイスドライバ | カーネル脆弱性対応、ドライバ調整 |
| U-Boot | ブートローダー | 起動プロセス制御 |
| Module FW | WiFiハードウェアモジュールのファームウェア | ハードウェア連携の安定性確保 |

これらに対してこれから実施されるペネトレーションテストや障害対応を見据えると、自分たちのサービスレイヤ（application）だけを触れる状態では不十分で、すべてのレイヤを把握・改善できる開発環境が必要でした。

特にペンテストでは、アプリケーション層だけでなく、カーネルやブートプロセスに関する指摘を受ける可能性があり、それらに迅速に対応するためにはフルスタックでの対応力が求められました。

## 開発環境の設計判断

### 理想として考えていた構成（Yocto / Poky）

一般的な組込みLinuxの開発において、理想的には Yocto Project / Poky を用いた構成を目指します。

なぜなら、Yoctoには以下の利点があるからです。

- レイヤとレシピによる依存関係管理
- BitBakeによる自動ビルド
- 誰がいつどの環境でビルドしても同一のrootfsを生成できる再現性

私自身これまでの経験から、今後の長期運用やCVE（Common Vulnerabilities and Exposures：共通脆弱性識別子）対応を考えるとこの構成が理想でした。

### 制約条件

しかし、理想的なYocto / Poky構成をそのまま採用することには、当時の開発体制において以下の制約がありました。

- ペンテスト対策や指摘に対する修正をフルスタックで迅速に実施したい
- 全メンバーが同一のビルド環境を維持することが難しい（ローカル環境の多様性）
- ビルド専用の高性能マシンを前提にできない
- Yoctoの学習コストがチーム全体での即応性を妨げる可能性

結果として、完全自動化よりも障害発生時に自分たちの手で改善できる構成を優先する判断をしました。

### 採用した構成

Shizen Boxでは、以下の運用重視の構成を採用しています。

- 各コンポーネント（application, kernel, U-Boot等）を独立したGitHubリポジトリで管理
- kernel / U-Boot は rootfs リポジトリの submodule として参照
- application / module-fw は独立したリポジトリで管理し、ビルド後のバイナリを rootfs へインストール
- 組み合わせ（スナップショット）でビルド状態を確定

```text
rootfs（親リポジトリ）
 ├── application (独立リポジトリ) → ビルド後バイナリをインストール
 ├── linux-kernel (submodule) → カーネルイメージを配置
 ├── u-boot (submodule) → ブートローダーを配置
 └── Module FW (独立リポジトリ) → ビルド後バイナリをインストール
```

この構成により、以下の運用上の利点を得られました。

- 属人性を排除してチームレビューできる（コンポーネントごとにPull Request）
- 特定レイヤをブラックボックス化せずフルスタックで対応できる
- 障害時にどこまで戻すか（どのsubmoduleを巻き戻すか）即断できる

## 実装で直面した課題と解決

### rootfsをGitで管理する問題

理想と現実のギャップが最も明確に問題として顕在化したのが、rootfsの扱いでした。

当初、実機に展開するrootfsをそのままGit管理しようとした結果、展開後の実機で以下の問題が発生しました。

#### setuidビット消失によるsudo不能

正常なsudoの場合、setuidは以下で確認できます。

```
$ ls -l /usr/bin/sudo
-rwsr-xr-x 1 root root ... /usr/bin/sudo
```

setuidが消えると

```
$ ls -l /usr/bin/sudo
-rwxr-xr-x 1 root root ... /usr/bin/sudo
   ↑ sではなくx
```

この状態でsudo実行した場合、下記のように実行できません。

```
$ sudo id
sudo: /usr/bin/sudo must be owned by uid 0 and have the setuid bit set
```

このようにrootfsをGit上で管理しようとした結果、Git上でパーミッションが壊れて、実機へ展開した際に管理者昇格が機能しなくなります。

#### /etc/shadowのパーミッション崩壊

正常な場合：

```
-rw------- 1 root root /etc/shadow
```

誤った場合：

```
-rw-r--r-- 1 root root /etc/shadow
```

結果：
```
passwd: Authentication token manipulation error
```

このようにGit上では微小なパーミッション崩れでも、組み込みOSとしては認証基盤が機能不全に陥ります。

#### なぜGitで壊れるか

Gitはプログラムのソースコードなど変更履歴を記録・追跡するための分散型バージョン管理システムです。

保持できるのは：
* 実行ビット
* ファイル内容

保持できないのは：
* 詳細パーミッション（600 / 644など）
* uid / gid
* デバイスノード
* 特殊ファイル属性

rootfsは「ファイル集合」であると同時に「属性集合」でもあるため、Gitでrootfsを完全再現するには不向きであることが分かりました。

### 方針転換：rootfsを成果物として扱わない

この経験から、方針を以下のように切り替えました。

- 実機に展開する rootfs 自体は Git 管理しない
- ベースとなる rootfs.tar.gz（ベンダー提供またはビルド済み）を展開
- その上に kernel / U-Boot / Module FW / application を重ねる

つまり、Git で管理するのは「rootfsの中身」ではなく、「rootfsを再現するための手順（スクリプト・設定ファイル）」です。

これは教科書的に正しいとは言えませんが、以下のメリットがあります。

- 意図しないパーミッション崩壊を防げる
- リポジトリサイズ問題を回避できる
- 同一手順で再現可能な rootfs を構築できる

この方針転換により、現時点では十分安定して運用できています。

### rootfs再現の具体的な手順

実際のrootfs構築は、以下のような手順で行っています。

1. **ベースrootfsの展開**
   ```bash
   # ベンダー提供またはビルド済みのrootfs.tar.gzを展開
   tar xzf rootfs.tar.gz -C ./build/rootfs/
   ```

2. **クロスアーキテクチャ環境の準備**
   ```bash
   # x86ホスト上でARM用rootfsを操作するため、qemu-arm-staticを配置
   # qemu-arm-staticは、ARM命令セットをx86上でエミュレートする静的バイナリ
   cp /usr/bin/qemu-arm-static ./build/rootfs/usr/bin/

   # rootfs構築用のfixupスクリプトを配置
   cp scripts/fixup ./build/rootfs/tmp/
   ```

3. **chrootでrootfs内に入り、パッケージ展開を実行**
   ```bash
   # chrootしてARM環境として実行
   sudo chroot ./build/rootfs /usr/bin/qemu-arm-static /bin/bash /tmp/fixup
   ```

4. **fixupスクリプト内での処理**
   ```bash
   #!/bin/bash
   # fixup の例

   # ipkパッケージ（opkg用のパッケージ形式）のインストール
   # opkgは組み込みLinux向けの軽量パッケージマネージャ
   opkg install /tmp/packages/*.ipk

   # Module FWのホストドライバをデプロイ
   cp -r /tmp/module-fw/drivers/* /lib/modules/$(uname -r)/

   # ドライバの依存関係を更新
   depmod -a

   # 必要に応じてカーネルモジュールのロード設定
   echo "module_name" >> /etc/modules
   ```

5. **後処理とクリーンアップ**
   ```bash
   # 作業用ファイルの削除
   sudo rm ./build/rootfs/usr/bin/qemu-arm-static
   sudo rm ./build/rootfs/tmp/fixup.sh
   ```

以上の方法で、x86ホスト上でARM用rootfsを構築しながら、パーミッションやパッケージ管理を正しくしています。qemu-arm-staticを使うことで、ARM用のバイナリをホストマシン上で実行可能になり、chrootした環境内でネイティブのパッケージマネージャ等を利用可能としています。

## 開発環境を支える2つのビルドパス

### なぜ2系統のビルドパスが必要か

前述した5つのレイヤを管理する上で、開発環境には以下の2つの異なる目的があります。

1. **キッティング**：ブランクまたは破損状態から初期状態を作る（フル構成）
2. **運用アップデート**：即応性・影響範囲を限定して素早く脆弱性改善や機能向上する（差分構成）

ペンテスト対応では、指摘された脆弱性に対して迅速に修正・検証・デプロイするサイクルが求められます。そのため、全体を再構築するキッティング用のパスと、差分更新可能な運用アップデート用のパスを分けることで、目的に応じた最適な対応が可能になります。

### データフロー概要

以下は、Shizen Box におけるキッティング（SD ブート）と運用中のShizen Boxへのリモートアップデートのデータフロー概要です。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4342076/4a3e0551-f480-477e-85ad-e3d3c2aec8da.png)

*図：キッティング（左）と運用アップデート（右）の2系統のビルドパス*

### パス① 運用アップデート用バイナリの生成と配布

運用アップデートでは、application リポジトリ内で管理している Docker 環境を起点にビルドします。

1. GitHub から各コンポーネントのリポジトリを取得
2. Docker 上でクロスコンパイルを行い、リモートアップデート用のバイナリを生成
3. 生成したバイナリをクラウドへ登録
4. クラウド側（デプロイサーバー）の仕組みによりShizen Box へ自動的に配布・更新

#### ipkパッケージの生成方法

ipkはopkg（組み込みLinux向けの軽量パッケージマネージャ）用のパッケージ形式です。ビルド環境は用途によって使い分けています。

- **applicationのビルド**: Docker環境でクロスコンパイルし、ipkパッケージを生成
- **汎用パッケージのビルド**: pokyのBitBakeを使用してipkパッケージを生成

```bash
# 汎用パッケージのビルド例
source poky/oe-init-build-env
bitbake <package-name>

# 生成されたipkファイルを取得
cp build/tmp/deploy/ipk/armv7a/*.ipk ./packages/
```

このように、Dockerによる迅速な開発と、pokyによる依存関係管理の恩恵を組み合わせたハイブリッドな構成としています。

このパス①の経路では、以下を重視しています。

- 差分更新による影響範囲の限定
- 障害時の切り分け容易性（どのコンポーネントが原因かを特定しやすい）
- 運用中のShizen Boxへの脆弱性改善の迅速なデプロイ

### パス② キッティング用 SD ブートイメージの生成

キッティング時には、運用時とは別のビルド環境を使用します。

1. ビルド環境で、各リポジトリを submodule として取得
2. application / kernel / U-Boot / Module FW を rootfs に展開
3. パッケージ・設定を含めた SD ブート用イメージを生成
4. 生成した SD イメージを SD カードへ書き込み
5. Shizen Box に挿入して初期状態を構築

このパス⓶の構成により、以下を達成しています。

- 初期状態の信頼性（全レイヤを含む完全な状態）
- 運用中アップデートの可視性（何が変更されたか追跡可能）
- レイヤ横断での調査容易性（問題発生時に全レイヤを調査可能）

今回の第三者ペネトレーションテストにおいても、このフルスタック開発環境を前提に application / rootfs / kernel / u-boot を跨いだ対策と脆弱性改善が可能となりました。

## おわりに

技術選定の正しさそのものよりも、誰が・いつ・最後まで責任を持って対応できるか。

Shizen Box の開発環境は、その問いに対する一つの現実解だと考えています。

理想的なYocto構成を採用できなかった背景には、チームの体制や開発スケジュールといった制約がありましたが、submodule方式とrootfs再現手順の管理によって、ペンテスト対応に必要なフルスタック対応力を確保できました。

次回（第二回）では、このフルスタック開発環境を前提に、ペンテスト実施前に行った事前の守備固め（侵入対策・DOS対策など）について紹介したいと思います。

同じような制約の中でIoT / 組み込み開発に向き合っている方の参考になれば幸いです。

### 注意事項

- 本記事は、公開可能な一般的技術知見をもとに、個人の経験として執筆しています。
- 特定の製品仕様、社内限定情報、非公開設定値、実環境を特定可能な情報は含んでいません。
- 設定値・構成・数値は一部簡略化または一般化しています。

記載内容はあくまで一例であり、すべてのIoT機器・システムにそのまま適用できるものではありません。実際の運用にあたっては、対象環境やリスクレベルに応じた検討が必要です。

### 参考記事

- [Raspberry Pi 4とWSL2を使ってYocto Project入門 - Qiita y-tsutsuさん](https://qiita.com/y-tsutsu/items/cbae3a2da083d42421c1)
- [Yocto Project 5.0により組み込みAIにも対応できるRaspberry Pi 5向けのカスタムLinuxディストリビューションをビルドする - Qiita - xtrizeShinoさん](https://qiita.com/xtrizeShino/items/91974cdc84bc8af24017)
- [Raspberry Pi のセルフビルド環境を QEMU で作る - Qiita - autchさん](https://qiita.com/autch/items/c8c9cdc7b8e5821e81a4)
- [Dockerや QEMU のハードウェアエミュレーションを使用せず chroot と QEMU スタティックモジュールのみでRaspberry Piのエミュレーション環境を起動する - Qiita - PINTOさん](https://qiita.com/PINTO/items/fd6b5f8d56b73bb37447)



