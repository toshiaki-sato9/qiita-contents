---
title: 001_shizenbox_devenv
tags:
  - 'Yocto'
private: true
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---
[O## はじめに

私たちShizen Connectは、「青い地球を未来へ繋ぐ」をミッションとして、再生可能エネルギーを効率良く生成・制御するために、クラウドからエッジまで全てのレイヤ技術を駆使して最先端のVPP技術を日々研究開発しています。

私はこの中で Shizen Box というエッジデバイスをメインに開発しています。

昨年、Shizen Boxは第三者ペネトレーションテスト（以下、ペンテスト）を実施しました。
本記事では、私がペンテスト対応した実務経験をもとに、設計・実装・運用の観点で得られた知見を整理した連載を予定しています。

- **第一回：開発・検証環境を整える**
- 第二回：事前の守備固め（侵入対策・DOS対策など）
- 第三回：第三者ペネトレーションテストの実施内容
- 第四回：指摘された脆弱性
- 第五回：対策と運用改善

※ 各回は単体でも読めますが、時系列で読むと全体像が分かる構成として書きたいと思っています。

## 第一回　開発・検証環境を整える

今回は、Shizen Box におけるフルスタック開発環境の設計と運用について説明します。

背景には、

- 第三者ペネトレーションテストが予定されていたこと  
- キッティングから運用まで、一貫して自分たちで責任を持てる環境を構築すること  
- 属人性を排除してチームレビュー可能な環境とすること

があります。

結果として、「理想的な構成」よりも  実運用で最後まで自分たちが責任を持てる構成を優先しました。今回は、その全体像と設計意図について紹介します。

## Shizen Boxを構成する5つのレイヤ

Shizen Box は、典型的な IoT / エッジデバイスと同様に、複数レイヤで構成されています。

- application
- rootfs
- Linux kernel
- U-Boot
- Module FW

これらに対してこれから実施されるペネトレーションテストや障害対応を見据えると、自分たちのサービスレイヤだけを触れる状態では不十分で、すべてのレイヤを把握・改善できる開発環境が必要でした。

### 理想として考えていた開発環境（Yocto / Poky)

一般的な組込みLinuxの開発において、理想的には Yocto Project / poky を用いた構成を目指します。
なぜならそこには、
- レイヤとレシピによる依存関係管理
- BitBakeによる自動ビルド
- だれがいつどの環境でビルドしても同一のrootfsを生成

といった、高い再現性と自動化を実現できるからです。
私自身これまでの経験から、今後の長期運用やCVE対応を考えるとこの構成が理想でした。

## 現実として採用した開発環境

一方でShizen Boxではこの理想構成をそのまま採用していません。
現状は、
- 各コンポーネントを独立したGitHubリポジトリで管理
- rootfsを起点にsubmoduleとして集約
- 組み合わせ（スナップショット）でビルド状態を確定

するといった、運用重視の構成をとっています。

```text
rootfs
 ├── application
 ├── linux kernel (submodule)
 ├── u-boot (submodule)
 └── Module FW 
```

この構成により、

* 属人性を排除してチームレビューできる
* 特定レイヤをブラックボックス化せずフルスタックで対応できる
* 障害時にどこまで戻すか即断できる

といった運用上の利点があります。

### 理想構成を断念した理由（制約条件）

理想的なYocto / poky構成を検討しなかったわけではありません。ただ、当時の条件として、

* ペンテスト対策や指摘に対する修正をフルスタックで実施したい
* 全メンバーが同一のビルド環境を維持することが難しい
* ビルド専用の高性能マシンを前提にできない

といった制約がありました。結果として、完全自動化よりも障害発生時に自分たちの手で改善できる構成を優先する判断をしました。

### 理想と現実のギャップで実際にハマった点

#### rootfsをGitで管理する破綻

このギャップが最も分かりやすく問題に直面化したのがrootfsの扱いでした。具体的には実機に展開するrootfsをそのままGit管理しようとした結果、

* パーミッション差分の意図しない混入
* /etc/passwd や /etc/shadow 周辺の属性崩れ
* setuid ビットの消失により sudo が使用不能になる

といった問題が発生しました。

これはGit管理的には正常でも、組み込みOSとしては運用不能な状態です。

### 現実解としての方針転換

#### rootfsを成果物として扱わない

この経験から、方針を切り替えて以下としました。
* 実機に展開する rootfs 自体は Git 管理しない
* ベースとなる rootfs.tar.gz を展開
* その上に kernel / U-Boot / Module FW / application を重ねる

つまり、Git で管理するのは rootfsの中身ではなく、rootfsを再現するための手順を構成管理することとしました。

これは教科書的に正しいとは言えませんが、以下のメリットがあります。
* 意図しないパーミッション崩壊を防げる
* リポジトリサイズ問題を回避できる
* 同一手順で再現可能な rootfs を構築できる

これらを理由に運用を始めて現時点では安定して運用に繋げることが出来ています。

### アップデート設計：2つのビルドパス

Shizen Box では、前述した 5 つのコンポーネントを以下の目的に応じて 2 系統のビルドパスで扱っています。

1. キッティング：ブランクまたは破損状態から初期状態を作る
2. 運用（リモート）アップデート：即応性・影響範囲を限定して素早く脆弱性改善や機能向上する

### キッティングと運用アップデートのデータフロー

以下は、Shizen Box におけるキッティング（SD ブート）と運用中のShizen Boxへのリモートアップデートのデータフロー概要です。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4342076/4a3e0551-f480-477e-85ad-e3d3c2aec8da.png)

### ① 運用アップデート用バイナリの生成と配布

運用アップデートでは、application 内で管理している Docker 環境を起点にビルドします。
GitHub から各コンポーネントを取得し、Docker 上でクロスコンパイルを行い、リモートアップデート用のバイナリを生成します。

生成したバイナリはクラウドへ登録し、クラウド側（デプロイサーバー）の仕組みによりShizen Box へ自動的に配布・更新されます。

この経路では、
* 差分更新
* 障害時の切り分け容易性
* 運用中のShizen Boxへの脆弱性改善

を重視しています。

### ② キッティング用 SD ブートイメージの生成

キッティング時には、運用時とは別のビルド環境を使用します。

VirtualBox 上のビルド環境で、各リポジトリを submodule として取得し、applicaton / kernel / U-Boot / Module FW を rootfs に展開、パッケージ・設定を含めた SD ブート用イメージを生成します。

生成した SD イメージを SD カードへ書き込み、Shizen Box に挿入して初期状態を構築します。

この構成により、先ほど述べた前述の目的を達成しつつ、

* 初期状態の信頼性
* 運用中アップデートの可視性
* レイヤ横断での調査容易性

を両立しています。

今回の第三者ペネトレーションテストにおいても、このフルスタック開発環境を前提に
application / rootfs / kernel / u-boot を跨いだ対策と脆弱性改善が可能となりました。

## おわりに

技術選定の正しさそのものよりも、誰が・いつ・最後まで責任を持って対応できるか。

Shizen Box の開発環境は、その問いに対する一つの現実解だと考えています。

同じような制約の中でIoT / 組み込み開発に向き合っている方の参考になれば幸いです。

### 注意事項

- 本記事は、公開可能な一般的技術知見をもとに、個人の経験として執筆しています。
- 特定の製品仕様、社内限定情報、非公開設定値、実環境を特定可能な情報は含んでいません。
- 設定値・構成・数値は一部簡略化または一般化しています。

記載内容はあくまで一例であり、すぺてのIoT機器・システムにそのまま適用できるものではありません。実際の運用にあたっては、対象環境やリスクレベルに応じた検討が必要です。

